{"ast":null,"code":"var http = require('http'),\n    https = require('https'),\n    common = require('../common'),\n    passes = exports;\n/*!\n * Array of passes.\n *\n * A `pass` is just a function that is executed on `req, socket, options`\n * so that you can easily add new checks while still keeping the base\n * flexible.\n */\n\n/*\n * Websockets Passes\n *\n */\n\n\nvar passes = exports;\n[\n/**\n * WebSocket requests must have the `GET` method and\n * the `upgrade:websocket` header\n *\n * @param {ClientRequest} Req Request object\n * @param {Socket} Websocket\n *\n * @api private\n */\nfunction checkMethodAndHeader(req, socket) {\n  if (req.method !== 'GET' || !req.headers.upgrade) {\n    socket.destroy();\n    return true;\n  }\n\n  if (req.headers.upgrade.toLowerCase() !== 'websocket') {\n    socket.destroy();\n    return true;\n  }\n},\n/**\n * Sets `x-forwarded-*` headers if specified in config.\n *\n * @param {ClientRequest} Req Request object\n * @param {Socket} Websocket\n * @param {Object} Options Config object passed to the proxy\n *\n * @api private\n */\nfunction XHeaders(req, socket, options) {\n  if (!options.xfwd) return;\n  var values = {\n    for: req.connection.remoteAddress || req.socket.remoteAddress,\n    port: common.getPort(req),\n    proto: common.hasEncryptedConnection(req) ? 'wss' : 'ws'\n  };\n  ['for', 'port', 'proto'].forEach(function (header) {\n    req.headers['x-forwarded-' + header] = (req.headers['x-forwarded-' + header] || '') + (req.headers['x-forwarded-' + header] ? ',' : '') + values[header];\n  });\n},\n/**\n * Does the actual proxying. Make the request and upgrade it\n * send the Switching Protocols request and pipe the sockets.\n *\n * @param {ClientRequest} Req Request object\n * @param {Socket} Websocket\n * @param {Object} Options Config object passed to the proxy\n *\n * @api private\n */\nfunction stream(req, socket, options, head, server, clb) {\n  common.setupSocket(socket);\n  if (head && head.length) socket.unshift(head);\n  var proxyReq = (common.isSSL.test(options.target.protocol) ? https : http).request(common.setupOutgoing(options.ssl || {}, options, req)); // Error Handler\n\n  proxyReq.on('error', onOutgoingError);\n  proxyReq.on('response', function (res) {\n    // if upgrade event isn't going to happen, close the socket\n    if (!res.upgrade) socket.end();\n  });\n  proxyReq.on('upgrade', function (proxyRes, proxySocket, proxyHead) {\n    proxySocket.on('error', onOutgoingError); // Allow us to listen when the websocket has completed\n\n    proxySocket.on('end', function () {\n      server.emit('close', proxyRes, proxySocket, proxyHead);\n    }); // The pipe below will end proxySocket if socket closes cleanly, but not\n    // if it errors (eg, vanishes from the net and starts returning\n    // EHOSTUNREACH). We need to do that explicitly.\n\n    socket.on('error', function () {\n      proxySocket.end();\n    });\n    common.setupSocket(proxySocket);\n    if (proxyHead && proxyHead.length) proxySocket.unshift(proxyHead);\n    socket.write('HTTP/1.1 101 Switching Protocols\\r\\n');\n    socket.write(Object.keys(proxyRes.headers).map(function (i) {\n      return i + \": \" + proxyRes.headers[i];\n    }).join('\\r\\n') + '\\r\\n\\r\\n');\n    proxySocket.pipe(socket).pipe(proxySocket);\n    server.emit('open', proxySocket);\n    server.emit('proxySocket', proxySocket); //DEPRECATED.\n  });\n  return proxyReq.end(); // XXX: CHECK IF THIS IS THIS CORRECT\n\n  function onOutgoingError(err) {\n    if (clb) {\n      clb(err, req, socket);\n    } else {\n      server.emit('error', err, req, socket);\n    }\n\n    socket.end();\n  }\n}] // <--\n.forEach(function (func) {\n  passes[func.name] = func;\n});","map":{"version":3,"sources":["/home/zecheng3/workspace/narrative_dectection/narrative_detection_frontend/node_modules/cors-anywhere/node_modules/http-proxy/lib/http-proxy/passes/ws-incoming.js"],"names":["http","require","https","common","passes","exports","checkMethodAndHeader","req","socket","method","headers","upgrade","destroy","toLowerCase","XHeaders","options","xfwd","values","for","connection","remoteAddress","port","getPort","proto","hasEncryptedConnection","forEach","header","stream","head","server","clb","setupSocket","length","unshift","proxyReq","isSSL","test","target","protocol","request","setupOutgoing","ssl","on","onOutgoingError","res","end","proxyRes","proxySocket","proxyHead","emit","write","Object","keys","map","i","join","pipe","err","func","name"],"mappings":"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","sourcesContent":["var http   = require('http'),\n    https  = require('https'),\n    common = require('../common'),\n    passes = exports;\n\n/*!\n * Array of passes.\n *\n * A `pass` is just a function that is executed on `req, socket, options`\n * so that you can easily add new checks while still keeping the base\n * flexible.\n */\n\n/*\n * Websockets Passes\n *\n */\n\nvar passes = exports;\n\n[\n  /**\n   * WebSocket requests must have the `GET` method and\n   * the `upgrade:websocket` header\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   *\n   * @api private\n   */\n\n  function checkMethodAndHeader (req, socket) {\n    if (req.method !== 'GET' || !req.headers.upgrade) {\n      socket.destroy();\n      return true;\n    }\n\n    if (req.headers.upgrade.toLowerCase() !== 'websocket') {\n      socket.destroy();\n      return true;\n    }\n  },\n\n  /**\n   * Sets `x-forwarded-*` headers if specified in config.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n\n  function XHeaders(req, socket, options) {\n    if(!options.xfwd) return;\n\n    var values = {\n      for  : req.connection.remoteAddress || req.socket.remoteAddress,\n      port : common.getPort(req),\n      proto: common.hasEncryptedConnection(req) ? 'wss' : 'ws'\n    };\n\n    ['for', 'port', 'proto'].forEach(function(header) {\n      req.headers['x-forwarded-' + header] =\n        (req.headers['x-forwarded-' + header] || '') +\n        (req.headers['x-forwarded-' + header] ? ',' : '') +\n        values[header];\n    });\n  },\n\n  /**\n   * Does the actual proxying. Make the request and upgrade it\n   * send the Switching Protocols request and pipe the sockets.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n  function stream(req, socket, options, head, server, clb) {\n    common.setupSocket(socket);\n\n    if (head && head.length) socket.unshift(head);\n\n\n    var proxyReq = (common.isSSL.test(options.target.protocol) ? https : http).request(\n      common.setupOutgoing(options.ssl || {}, options, req)\n    );\n    // Error Handler\n    proxyReq.on('error', onOutgoingError);\n    proxyReq.on('response', function (res) {\n      // if upgrade event isn't going to happen, close the socket\n      if (!res.upgrade) socket.end();\n    });\n\n    proxyReq.on('upgrade', function(proxyRes, proxySocket, proxyHead) {\n      proxySocket.on('error', onOutgoingError);\n\n      // Allow us to listen when the websocket has completed\n      proxySocket.on('end', function () {\n        server.emit('close', proxyRes, proxySocket, proxyHead);\n      });\n\n      // The pipe below will end proxySocket if socket closes cleanly, but not\n      // if it errors (eg, vanishes from the net and starts returning\n      // EHOSTUNREACH). We need to do that explicitly.\n      socket.on('error', function () {\n        proxySocket.end();\n      });\n\n      common.setupSocket(proxySocket);\n\n      if (proxyHead && proxyHead.length) proxySocket.unshift(proxyHead);\n\n      socket.write('HTTP/1.1 101 Switching Protocols\\r\\n');\n      socket.write(Object.keys(proxyRes.headers).map(function(i) {\n        return i + \": \" + proxyRes.headers[i];\n      }).join('\\r\\n') + '\\r\\n\\r\\n');\n      proxySocket.pipe(socket).pipe(proxySocket);\n\n      server.emit('open', proxySocket);\n      server.emit('proxySocket', proxySocket);  //DEPRECATED.\n    });\n\n    return proxyReq.end(); // XXX: CHECK IF THIS IS THIS CORRECT\n\n    function onOutgoingError(err) {\n      if (clb) {\n        clb(err, req, socket);\n      } else {\n        server.emit('error', err, req, socket);\n      }\n      socket.end();\n    }\n  }\n\n] // <--\n  .forEach(function(func) {\n    passes[func.name] = func;\n  });\n"]},"metadata":{},"sourceType":"script"}