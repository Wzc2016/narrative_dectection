{"ast":null,"code":"var http = require('http'),\n    https = require('https'),\n    web_o = require('./web-outgoing'),\n    common = require('../common'),\n    passes = exports;\n\nweb_o = Object.keys(web_o).map(function (pass) {\n  return web_o[pass];\n});\n/*!\n * Array of passes.\n *\n * A `pass` is just a function that is executed on `req, res, options`\n * so that you can easily add new checks while still keeping the base\n * flexible.\n */\n\n[// <--\n\n/**\n * Sets `content-length` to '0' if request is of DELETE type.\n *\n * @param {ClientRequest} Req Request object\n * @param {IncomingMessage} Res Response object\n * @param {Object} Options Config object passed to the proxy\n *\n * @api private\n */\nfunction deleteLength(req, res, options) {\n  if ((req.method === 'DELETE' || req.method === 'OPTIONS') && !req.headers['content-length']) {\n    req.headers['content-length'] = '0';\n  }\n},\n/**\n * Sets timeout in request socket if it was specified in options.\n *\n * @param {ClientRequest} Req Request object\n * @param {IncomingMessage} Res Response object\n * @param {Object} Options Config object passed to the proxy\n *\n * @api private\n */\nfunction timeout(req, res, options) {\n  if (options.timeout) {\n    req.socket.setTimeout(options.timeout);\n  }\n},\n/**\n * Sets `x-forwarded-*` headers if specified in config.\n *\n * @param {ClientRequest} Req Request object\n * @param {IncomingMessage} Res Response object\n * @param {Object} Options Config object passed to the proxy\n *\n * @api private\n */\nfunction XHeaders(req, res, options) {\n  if (!options.xfwd) return;\n  var encrypted = req.isSpdy || common.hasEncryptedConnection(req);\n  var values = {\n    for: req.connection.remoteAddress || req.socket.remoteAddress,\n    port: common.getPort(req),\n    proto: encrypted ? 'https' : 'http'\n  };\n  ['for', 'port', 'proto'].forEach(function (header) {\n    req.headers['x-forwarded-' + header] = (req.headers['x-forwarded-' + header] || '') + (req.headers['x-forwarded-' + header] ? ',' : '') + values[header];\n  });\n},\n/**\n * Does the actual proxying. If `forward` is enabled fires up\n * a ForwardStream, same happens for ProxyStream. The request\n * just dies otherwise.\n *\n * @param {ClientRequest} Req Request object\n * @param {IncomingMessage} Res Response object\n * @param {Object} Options Config object passed to the proxy\n *\n * @api private\n */\nfunction stream(req, res, options, _, server, clb) {\n  // And we begin!\n  server.emit('start', req, res, options.target);\n\n  if (options.forward) {\n    // If forward enable, so just pipe the request\n    var forwardReq = (options.forward.protocol === 'https:' ? https : http).request(common.setupOutgoing(options.ssl || {}, options, req, 'forward'));\n    (options.buffer || req).pipe(forwardReq);\n\n    if (!options.target) {\n      return res.end();\n    }\n  } // Request initalization\n\n\n  var proxyReq = (options.target.protocol === 'https:' ? https : http).request(common.setupOutgoing(options.ssl || {}, options, req)); // Enable developers to modify the proxyReq before headers are sent\n\n  proxyReq.on('socket', function (socket) {\n    if (server) {\n      server.emit('proxyReq', proxyReq, req, res, options);\n    }\n  }); // allow outgoing socket to timeout so that we could\n  // show an error page at the initial request\n\n  if (options.proxyTimeout) {\n    proxyReq.setTimeout(options.proxyTimeout, function () {\n      proxyReq.abort();\n    });\n  } // Ensure we abort proxy if request is aborted\n\n\n  req.on('aborted', function () {\n    proxyReq.abort();\n  }); // Handle errors on incoming request as well as it makes sense to\n\n  req.on('error', proxyError); // Error Handler\n\n  proxyReq.on('error', proxyError);\n\n  function proxyError(err) {\n    if (clb) {\n      clb(err, req, res, options.target);\n    } else {\n      server.emit('error', err, req, res, options.target);\n    }\n  }\n\n  (options.buffer || req).pipe(proxyReq);\n  proxyReq.on('response', function (proxyRes) {\n    if (server) {\n      server.emit('proxyRes', proxyRes, req, res);\n    }\n\n    for (var i = 0; i < web_o.length; i++) {\n      if (web_o[i](req, res, proxyRes, options)) {\n        break;\n      }\n    } // Allow us to listen when the proxy has completed\n\n\n    proxyRes.on('end', function () {\n      server.emit('end', req, res, proxyRes);\n    });\n    proxyRes.pipe(res);\n  }); //proxyReq.end();\n}] // <--\n.forEach(function (func) {\n  passes[func.name] = func;\n});","map":{"version":3,"sources":["/home/zecheng3/workspace/narrative_dectection/narrative_detection_frontend/node_modules/cors-anywhere/node_modules/http-proxy/lib/http-proxy/passes/web-incoming.js"],"names":["http","require","https","web_o","common","passes","exports","Object","keys","map","pass","deleteLength","req","res","options","method","headers","timeout","socket","setTimeout","XHeaders","xfwd","encrypted","isSpdy","hasEncryptedConnection","values","for","connection","remoteAddress","port","getPort","proto","forEach","header","stream","_","server","clb","emit","target","forward","forwardReq","protocol","request","setupOutgoing","ssl","buffer","pipe","end","proxyReq","on","proxyTimeout","abort","proxyError","err","proxyRes","i","length","func","name"],"mappings":"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","sourcesContent":["var http   = require('http'),\n    https  = require('https'),\n    web_o  = require('./web-outgoing'),\n    common = require('../common'),\n    passes = exports;\n\nweb_o = Object.keys(web_o).map(function(pass) {\n  return web_o[pass];\n});\n\n/*!\n * Array of passes.\n *\n * A `pass` is just a function that is executed on `req, res, options`\n * so that you can easily add new checks while still keeping the base\n * flexible.\n */\n\n[ // <--\n\n  /**\n   * Sets `content-length` to '0' if request is of DELETE type.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n\n  function deleteLength(req, res, options) {\n    if((req.method === 'DELETE' || req.method === 'OPTIONS')\n       && !req.headers['content-length']) {\n      req.headers['content-length'] = '0';\n    }\n  },\n\n  /**\n   * Sets timeout in request socket if it was specified in options.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n\n  function timeout(req, res, options) {\n    if(options.timeout) {\n      req.socket.setTimeout(options.timeout);\n    }\n  },\n\n  /**\n   * Sets `x-forwarded-*` headers if specified in config.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n\n  function XHeaders(req, res, options) {\n    if(!options.xfwd) return;\n\n    var encrypted = req.isSpdy || common.hasEncryptedConnection(req);\n    var values = {\n      for  : req.connection.remoteAddress || req.socket.remoteAddress,\n      port : common.getPort(req),\n      proto: encrypted ? 'https' : 'http'\n    };\n\n    ['for', 'port', 'proto'].forEach(function(header) {\n      req.headers['x-forwarded-' + header] =\n        (req.headers['x-forwarded-' + header] || '') +\n        (req.headers['x-forwarded-' + header] ? ',' : '') +\n        values[header];\n    });\n  },\n\n  /**\n   * Does the actual proxying. If `forward` is enabled fires up\n   * a ForwardStream, same happens for ProxyStream. The request\n   * just dies otherwise.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n\n  function stream(req, res, options, _, server, clb) {\n\n    // And we begin!\n    server.emit('start', req, res, options.target)\n    if(options.forward) {\n      // If forward enable, so just pipe the request\n      var forwardReq = (options.forward.protocol === 'https:' ? https : http).request(\n        common.setupOutgoing(options.ssl || {}, options, req, 'forward')\n      );\n      (options.buffer || req).pipe(forwardReq);\n      if(!options.target) { return res.end(); }\n    }\n\n    // Request initalization\n    var proxyReq = (options.target.protocol === 'https:' ? https : http).request(\n      common.setupOutgoing(options.ssl || {}, options, req)\n    );\n\n    // Enable developers to modify the proxyReq before headers are sent\n    proxyReq.on('socket', function(socket) {\n      if(server) { server.emit('proxyReq', proxyReq, req, res, options); }\n    });\n\n    // allow outgoing socket to timeout so that we could\n    // show an error page at the initial request\n    if(options.proxyTimeout) {\n      proxyReq.setTimeout(options.proxyTimeout, function() {\n         proxyReq.abort();\n      });\n    }\n\n    // Ensure we abort proxy if request is aborted\n    req.on('aborted', function () {\n      proxyReq.abort();\n    });\n\n    // Handle errors on incoming request as well as it makes sense to\n    req.on('error', proxyError);\n\n    // Error Handler\n    proxyReq.on('error', proxyError);\n\n    function proxyError (err){\n      if (clb) {\n        clb(err, req, res, options.target);\n      } else {\n        server.emit('error', err, req, res, options.target);\n      }\n    }\n\n    (options.buffer || req).pipe(proxyReq);\n\n    proxyReq.on('response', function(proxyRes) {\n      if(server) { server.emit('proxyRes', proxyRes, req, res); }\n      for(var i=0; i < web_o.length; i++) {\n        if(web_o[i](req, res, proxyRes, options)) { break; }\n      }\n\n      // Allow us to listen when the proxy has completed\n      proxyRes.on('end', function () {\n        server.emit('end', req, res, proxyRes);\n      });\n\n      proxyRes.pipe(res);\n    });\n\n    //proxyReq.end();\n  }\n\n] // <--\n  .forEach(function(func) {\n    passes[func.name] = func;\n  });\n"]},"metadata":{},"sourceType":"script"}