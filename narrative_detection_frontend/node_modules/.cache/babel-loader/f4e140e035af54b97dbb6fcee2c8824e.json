{"ast":null,"code":"var url = require('url'),\n    passes = exports;\n\nvar redirectRegex = /^30(1|2|7|8)$/;\n/*!\n * Array of passes.\n *\n * A `pass` is just a function that is executed on `req, res, options`\n * so that you can easily add new checks while still keeping the base\n * flexible.\n */\n\n[// <--\n\n/**\n * If is a HTTP 1.0 request, remove chunk headers\n *\n * @param {ClientRequest} Req Request object\n * @param {IncomingMessage} Res Response object\n * @param {proxyResponse} Res Response object from the proxy request\n *\n * @api private\n */\nfunction removeChunked(req, res, proxyRes) {\n  if (req.httpVersion === '1.0') {\n    delete proxyRes.headers['transfer-encoding'];\n  }\n},\n/**\n * If is a HTTP 1.0 request, set the correct connection header\n * or if connection header not present, then use `keep-alive`\n *\n * @param {ClientRequest} Req Request object\n * @param {IncomingMessage} Res Response object\n * @param {proxyResponse} Res Response object from the proxy request\n *\n * @api private\n */\nfunction setConnection(req, res, proxyRes) {\n  if (req.httpVersion === '1.0') {\n    proxyRes.headers.connection = req.headers.connection || 'close';\n  } else if (!proxyRes.headers.connection) {\n    proxyRes.headers.connection = req.headers.connection || 'keep-alive';\n  }\n}, function setRedirectHostRewrite(req, res, proxyRes, options) {\n  if ((options.hostRewrite || options.autoRewrite || options.protocolRewrite) && proxyRes.headers['location'] && redirectRegex.test(proxyRes.statusCode)) {\n    var target = url.parse(options.target);\n    var u = url.parse(proxyRes.headers['location']); // make sure the redirected host matches the target host before rewriting\n\n    if (target.host != u.host) {\n      return;\n    }\n\n    if (options.hostRewrite) {\n      u.host = options.hostRewrite;\n    } else if (options.autoRewrite) {\n      u.host = req.headers['host'];\n    }\n\n    if (options.protocolRewrite) {\n      u.protocol = options.protocolRewrite;\n    }\n\n    proxyRes.headers['location'] = u.format();\n  }\n},\n/**\n * Copy headers from proxyResponse to response\n * set each header in response object.\n *\n * @param {ClientRequest} Req Request object\n * @param {IncomingMessage} Res Response object\n * @param {proxyResponse} Res Response object from the proxy request\n *\n * @api private\n */\nfunction writeHeaders(req, res, proxyRes) {\n  Object.keys(proxyRes.headers).forEach(function (key) {\n    res.setHeader(key, proxyRes.headers[key]);\n  });\n},\n/**\n * Set the statusCode from the proxyResponse\n *\n * @param {ClientRequest} Req Request object\n * @param {IncomingMessage} Res Response object\n * @param {proxyResponse} Res Response object from the proxy request\n *\n * @api private\n */\nfunction writeStatusCode(req, res, proxyRes) {\n  res.writeHead(proxyRes.statusCode);\n}] // <--\n.forEach(function (func) {\n  passes[func.name] = func;\n});","map":{"version":3,"sources":["/home/zecheng3/workspace/narrative_dectection/narrative_detection_frontend/node_modules/cors-anywhere/node_modules/http-proxy/lib/http-proxy/passes/web-outgoing.js"],"names":["url","require","passes","exports","redirectRegex","removeChunked","req","res","proxyRes","httpVersion","headers","setConnection","connection","setRedirectHostRewrite","options","hostRewrite","autoRewrite","protocolRewrite","test","statusCode","target","parse","u","host","protocol","format","writeHeaders","Object","keys","forEach","key","setHeader","writeStatusCode","writeHead","func","name"],"mappings":"AAAA,IAAIA,GAAG,GAAMC,OAAO,CAAC,KAAD,CAApB;AAAA,IACIC,MAAM,GAAGC,OADb;;AAGA,IAAIC,aAAa,GAAG,eAApB;AAEA;;;;;;;;AAQA,CAAE;;AAEA;;;;;;;;;AASA,SAASC,aAAT,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAiCC,QAAjC,EAA2C;AACzC,MAAIF,GAAG,CAACG,WAAJ,KAAoB,KAAxB,EAA+B;AAC7B,WAAOD,QAAQ,CAACE,OAAT,CAAiB,mBAAjB,CAAP;AACD;AACF,CAfH;AAiBE;;;;;;;;;;AAUA,SAASC,aAAT,CAAuBL,GAAvB,EAA4BC,GAA5B,EAAiCC,QAAjC,EAA2C;AACzC,MAAIF,GAAG,CAACG,WAAJ,KAAoB,KAAxB,EAA+B;AAC7BD,IAAAA,QAAQ,CAACE,OAAT,CAAiBE,UAAjB,GAA8BN,GAAG,CAACI,OAAJ,CAAYE,UAAZ,IAA0B,OAAxD;AACD,GAFD,MAEO,IAAI,CAACJ,QAAQ,CAACE,OAAT,CAAiBE,UAAtB,EAAkC;AACvCJ,IAAAA,QAAQ,CAACE,OAAT,CAAiBE,UAAjB,GAA8BN,GAAG,CAACI,OAAJ,CAAYE,UAAZ,IAA0B,YAAxD;AACD;AACF,CAjCH,EAmCE,SAASC,sBAAT,CAAgCP,GAAhC,EAAqCC,GAArC,EAA0CC,QAA1C,EAAoDM,OAApD,EAA6D;AAC3D,MAAI,CAACA,OAAO,CAACC,WAAR,IAAuBD,OAAO,CAACE,WAA/B,IAA8CF,OAAO,CAACG,eAAvD,KACGT,QAAQ,CAACE,OAAT,CAAiB,UAAjB,CADH,IAEGN,aAAa,CAACc,IAAd,CAAmBV,QAAQ,CAACW,UAA5B,CAFP,EAEgD;AAC9C,QAAIC,MAAM,GAAGpB,GAAG,CAACqB,KAAJ,CAAUP,OAAO,CAACM,MAAlB,CAAb;AACA,QAAIE,CAAC,GAAGtB,GAAG,CAACqB,KAAJ,CAAUb,QAAQ,CAACE,OAAT,CAAiB,UAAjB,CAAV,CAAR,CAF8C,CAI9C;;AACA,QAAIU,MAAM,CAACG,IAAP,IAAeD,CAAC,CAACC,IAArB,EAA2B;AACzB;AACD;;AAED,QAAIT,OAAO,CAACC,WAAZ,EAAyB;AACvBO,MAAAA,CAAC,CAACC,IAAF,GAAST,OAAO,CAACC,WAAjB;AACD,KAFD,MAEO,IAAID,OAAO,CAACE,WAAZ,EAAyB;AAC9BM,MAAAA,CAAC,CAACC,IAAF,GAASjB,GAAG,CAACI,OAAJ,CAAY,MAAZ,CAAT;AACD;;AACD,QAAII,OAAO,CAACG,eAAZ,EAA6B;AAC3BK,MAAAA,CAAC,CAACE,QAAF,GAAaV,OAAO,CAACG,eAArB;AACD;;AAEDT,IAAAA,QAAQ,CAACE,OAAT,CAAiB,UAAjB,IAA+BY,CAAC,CAACG,MAAF,EAA/B;AACD;AACF,CA1DH;AA2DE;;;;;;;;;;AAUA,SAASC,YAAT,CAAsBpB,GAAtB,EAA2BC,GAA3B,EAAgCC,QAAhC,EAA0C;AACxCmB,EAAAA,MAAM,CAACC,IAAP,CAAYpB,QAAQ,CAACE,OAArB,EAA8BmB,OAA9B,CAAsC,UAASC,GAAT,EAAc;AAClDvB,IAAAA,GAAG,CAACwB,SAAJ,CAAcD,GAAd,EAAmBtB,QAAQ,CAACE,OAAT,CAAiBoB,GAAjB,CAAnB;AACD,GAFD;AAGD,CAzEH;AA2EE;;;;;;;;;AASA,SAASE,eAAT,CAAyB1B,GAAzB,EAA8BC,GAA9B,EAAmCC,QAAnC,EAA6C;AAC3CD,EAAAA,GAAG,CAAC0B,SAAJ,CAAczB,QAAQ,CAACW,UAAvB;AACD,CAtFH,EAwFE;AAxFF,CAyFGU,OAzFH,CAyFW,UAASK,IAAT,EAAe;AACtBhC,EAAAA,MAAM,CAACgC,IAAI,CAACC,IAAN,CAAN,GAAoBD,IAApB;AACD,CA3FH","sourcesContent":["var url    = require('url'),\n    passes = exports;\n\nvar redirectRegex = /^30(1|2|7|8)$/;\n\n/*!\n * Array of passes.\n *\n * A `pass` is just a function that is executed on `req, res, options`\n * so that you can easily add new checks while still keeping the base\n * flexible.\n */\n\n[ // <--\n\n  /**\n   * If is a HTTP 1.0 request, remove chunk headers\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {proxyResponse} Res Response object from the proxy request\n   *\n   * @api private\n   */\n  function removeChunked(req, res, proxyRes) {\n    if (req.httpVersion === '1.0') {\n      delete proxyRes.headers['transfer-encoding'];\n    }\n  },\n\n  /**\n   * If is a HTTP 1.0 request, set the correct connection header\n   * or if connection header not present, then use `keep-alive`\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {proxyResponse} Res Response object from the proxy request\n   *\n   * @api private\n   */\n  function setConnection(req, res, proxyRes) {\n    if (req.httpVersion === '1.0') {\n      proxyRes.headers.connection = req.headers.connection || 'close';\n    } else if (!proxyRes.headers.connection) {\n      proxyRes.headers.connection = req.headers.connection || 'keep-alive';\n    }\n  },\n\n  function setRedirectHostRewrite(req, res, proxyRes, options) {\n    if ((options.hostRewrite || options.autoRewrite || options.protocolRewrite)\n        && proxyRes.headers['location']\n        && redirectRegex.test(proxyRes.statusCode)) {\n      var target = url.parse(options.target);\n      var u = url.parse(proxyRes.headers['location']);\n\n      // make sure the redirected host matches the target host before rewriting\n      if (target.host != u.host) {\n        return;\n      }\n\n      if (options.hostRewrite) {\n        u.host = options.hostRewrite;\n      } else if (options.autoRewrite) {\n        u.host = req.headers['host'];\n      }\n      if (options.protocolRewrite) {\n        u.protocol = options.protocolRewrite;\n      }\n\n      proxyRes.headers['location'] = u.format();\n    }\n  },\n  /**\n   * Copy headers from proxyResponse to response\n   * set each header in response object.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {proxyResponse} Res Response object from the proxy request\n   *\n   * @api private\n   */\n  function writeHeaders(req, res, proxyRes) {\n    Object.keys(proxyRes.headers).forEach(function(key) {\n      res.setHeader(key, proxyRes.headers[key]);\n    });\n  },\n\n  /**\n   * Set the statusCode from the proxyResponse\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {proxyResponse} Res Response object from the proxy request\n   *\n   * @api private\n   */\n  function writeStatusCode(req, res, proxyRes) {\n    res.writeHead(proxyRes.statusCode);\n  }\n\n] // <--\n  .forEach(function(func) {\n    passes[func.name] = func;\n  });\n"]},"metadata":{},"sourceType":"script"}